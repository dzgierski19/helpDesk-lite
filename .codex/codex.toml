# Auto-generated from .gemini/commands.yaml
# Run `npm run sync:commands` after editing Gemini slash commands.

[commands."backend:make-controllers"]
prompt = """
As a Laravel developer, your task is to generate the necessary API routes and a controller based on the provided `project_spec.md`, existing Enum files, and Model files.
The database used is PostgreSQL.

{{file "project_spec.md"}}
{{file "backend/app/Enums/UserRole.php"}}
{{file "backend/app/Enums/TicketPriority.php"}}
{{file "backend/app/Enums/TicketStatus.php"}}
{{file "backend/app/Models/User.php"}}
{{file "backend/app/Models/Ticket.php"}}
{{file "backend/app/Models/TicketStatusChange.php"}}

You need to create a `TicketController.php` and modify `api.php` to define the API endpoints.

**1. Create `TicketController.php` (`backend/app/Http/Controllers/TicketController.php`):**
   - Implement methods for all CRUD operations for tickets (`index`, `store`, `show`, `update`, `destroy`).
   - Implement `triageSuggest(Request $request, Ticket $ticket)` method.
   - Implement `externalUserInfo()` method.

   **Specific Logic for Controller Methods:**
   - **`index(Request $request)`:**
     - Retrieve tickets, applying filters by `status`, `priority`, `assignee_id`, and `tag` from the request query parameters.
     - **Authorization Logic:** If the `X-USER-ROLE` header is 'reporter', filter tickets to show only those where `creator_id` matches the ID of the reporter user (assume reporter user ID is 3, as per our seeding plan). Otherwise, return all tickets.
     - Return tickets as a JSON response.
   - **`store(Request $request)`:**
     - Validate incoming request data for `title`, `description`, `priority`, `status`, `assignee_id`, `tags`.
     - Create a new `Ticket` instance.
     - Set `creator_id` based on the `X-USER-ROLE` header (assume reporter user ID is 3).
     - Return the created ticket as a JSON response.
   - **`show(Ticket $ticket)`:**
     - Return the specified `Ticket` instance.
     - Ensure the `assignee` relationship is loaded (e.g., `Ticket::with('assignee')->findOrFail($id)`).
   - **`update(Request $request, Ticket $ticket)`:**
     - Validate incoming request data.
     - If the `status` field is being updated and its value changes, create a new `TicketStatusChange` record.
     - Update the `Ticket` instance.
     - Return the updated ticket as a JSON response.
   - **`destroy(Ticket $ticket)`:**
     - Delete the specified `Ticket` instance.
     - Return a success response (e.g., 204 No Content).
   - **`triageSuggest(Request $request, Ticket $ticket)`:**
     - Return the hardcoded JSON response as specified in `project_spec.md`: `{"suggested_status": "in_progress", "suggested_priority": "high", "suggested_tags": ["triage", "auto"]}`.
   - **`externalUserInfo()`:**
     - Make an HTTP GET request to `https://jsonplaceholder.typicode.com/users/1`.
     - Cache the response for 10 minutes.
     - Extract and return only the `name` from the external API response.
     - Handle potential HTTP request errors (e.g., network issues, API down) by returning `{"error": "external_api_failed"}`.

**2. Modify `api.php` (`backend/routes/api.php`):**
   - Define API routes for all methods in `TicketController`.
   - Use `Route::apiResource` for the standard CRUD operations.
   - Define specific routes for `POST /tickets/{id}/triage-suggest` and `GET /external/user-info`.
   - Ensure routes are accessible without explicit authentication middleware for now, as per `project_spec.md` (fake login).

Provide the full PHP code for `backend/app/Http/Controllers/TicketController.php` and `backend/routes/api.php`.

"""

[commands."backend:make-migrations"]
prompt = """
As a Laravel developer, your task is to generate the necessary database migration files based on the provided `project_spec.md`.
The database used is PostgreSQL.

{{file "project_spec.md"}}

You need to create or modify three migration files for the following models: `User`, `Ticket`, and `TicketStatusChange`.

**1. Users Table Migration (Modify existing):**
   - Modify the existing `create_users_table` migration to add a `role` column.
   - `role`: enum with values `admin`, `agent`, `reporter`. This column should be added after the `password` column.

**2. Tickets Table Migration (New file):**
   - Create a new migration file for the `tickets` table.
   - Fields:
     - `id`: primary key, auto-increment.
     - `title`: string (255), required.
     - `description`: text, required.
     - `priority`: enum with values `low`, `medium`, `high`.
     - `status`: enum with values `new`, `in_progress`, `resolved`.
     - `assignee_id`: integer, nullable, foreign key to `users.id`.
     - `creator_id`: integer, required, foreign key to `users.id`.
     - `tags`: json.
     - `created_at`: timestamp.
     - `updated_at`: timestamp.
   - Ensure foreign key constraints are correctly defined.

**3. TicketStatusChanges Table Migration (New file):**
   - Create a new migration file for the `ticket_status_changes` table.
   - Fields:
     - `id`: primary key, auto-increment.
     - `ticket_id`: integer, foreign key to `tickets.id`.
     - `old_status`: enum with values `new`, `in_progress`, `resolved`.
     - `new_status`: enum with values `new`, `in_progress`, `resolved`.
     - `changed_at`: timestamp.
   - Ensure foreign key constraints are correctly defined.

Place all generated migration files in the `backend/database/migrations/` directory.
Provide the full PHP code for each migration file.

"""

[commands."backend:make-models"]
prompt = """
As a Laravel developer, your task is to generate the necessary Eloquent Model files based on the provided `project_spec.md`.
The database used is PostgreSQL.

{{file "project_spec.md"}}

You need to create or modify three Eloquent Model files: `User.php`, `Ticket.php`, and `TicketStatusChange.php`.

**1. User Model (Modify existing `User.php`):**
   - Add `role` to the `$casts` property, casting it as a string enum. The enum values are `admin`, `agent`, `reporter`.
   - Define a `ticketsCreated()` relationship: a user can create many tickets (hasMany `Ticket` where `creator_id` is the foreign key).
   - Define a `ticketsAssigned()` relationship: a user can be assigned many tickets (hasMany `Ticket` where `assignee_id` is the foreign key).

**2. Ticket Model (Create `Ticket.php`):**
   - Define the `$fillable` property to allow mass assignment for `title`, `description`, `priority`, `status`, `assignee_id`, `creator_id`, `tags`.
   - Define the `$casts` property for:
     - `priority`: cast as a string enum (`low`, `medium`, `high`).
     - `status`: cast as a string enum (`new`, `in_progress`, `resolved`).
     - `tags`: cast as `array` (Laravel will handle JSON serialization/deserialization).
   - Define a `assignee()` relationship: a ticket belongs to an `assignee` (belongsTo `User`, using `assignee_id`).
   - Define a `creator()` relationship: a ticket belongs to a `creator` (belongsTo `User`, using `creator_id`).
     - Define a `statusChanges()` relationship: a ticket has many `TicketStatusChange` records (hasMany `TicketStatusChange`).

**3. TicketStatusChange Model (Create `TicketStatusChange.php`):**
   - Define the `$fillable` property to allow mass assignment for `ticket_id`, `old_status`, `new_status`.
   - Define the `$casts` property for:
     - `old_status`: cast as a string enum (`new`, `in_progress`, `resolved`).
     - `new_status`: cast as a string enum (`new`, `in_progress`, `resolved`).
     - `changed_at`: cast as `datetime`.
   - Define a `ticket()` relationship: a status change belongs to a `Ticket` (belongsTo `Ticket`).

Place all generated model files in the `backend/app/Models/` directory.
Provide the full PHP code for each model file.

"""

[commands."backend:make-seeders"]
prompt = """
As a Laravel developer, your task is to create database seeders based on the provided `project_spec.md` and the existing Enum files.
The database used is PostgreSQL.

{{file "project_spec.md"}}
{{file "backend/app/Enums/UserRole.php"}}
{{file "backend/app/Enums/TicketPriority.php"}}
{{file "backend/app/Enums/TicketStatus.php"}}

Your task is to populate the `run` method of the main `DatabaseSeeder.php` file.

**Instructions:**

1.  **Create Users:**
    - Create exactly three users using the `User` model factory.
    - One user for each role defined in the `UserRole` enum (`admin`, `agent`, `reporter`).
    - Use the `UserRole` enum when setting the role.
    - Use a static password like 'password' for all users.
    - Store the created 'reporter' user in a variable for later use.

2.  **Create Tickets:**
    - Create at least 5 sample tickets using the `Ticket` model factory.
    - For the `creator_id` of all tickets, use the ID of the 'reporter' user you created above.
    - For the `assignee_id`, you can randomly assign the 'admin' or 'agent' user, or leave it null on some tickets.
    - Use the `TicketStatus` and `TicketPriority` enums for the `status` and `priority` fields.
    - For the `tags` field, provide a sample JSON array of strings (e.g., `['api', 'bug']`).
    - Use Faker for realistic titles and descriptions.

3.  **Update DatabaseSeeder:**
    - Ensure the `run()` method in `backend/database/seeders/DatabaseSeeder.php` contains all the logic to create these users and tickets.
    - Do not add any logic to truncate or refresh the database; just the creation logic.

Provide the full, updated PHP code for the `backend/database/seeders/DatabaseSeeder.php` file.

"""

[commands."backend:make-tests-feature-crud"]
prompt = """
As a Laravel developer, your task is to create a feature test file to verify the basic CRUD functionality of the tickets API.

**Context Files:**
{{file "backend/routes/api.php"}}
{{file "backend/app/Http/Controllers/TicketController.php"}}
{{file "backend/app/Models/User.php"}}
{{file "backend/app/Models/Ticket.php"}}
{{file "backend/database/factories/UserFactory.php"}}
{{file "backend/database/factories/TicketFactory.php"}}
{{file "backend/app/Enums/UserRole.php"}}

You need to create a new PHPUnit test file: `backend/tests/Feature/TicketCrudTest.php`.

**Instructions:**

1.  **Test File Setup:**
    - Create a test class `TicketCrudTest` that extends `Tests\TestCase`.
    - Use the `RefreshDatabase` trait.
    - In a `setUp()` method, create one user for each role (`admin`, `agent`, `reporter`) and store them as properties of the test class (e.g., `$this->reporter`, `$this->agent`) for easy access in all tests.

2.  **Test `POST /api/tickets` (Store):**
    - Write a test method `test_it_can_create_a_ticket()`.
    - Prepare valid ticket data (title, description, priority, etc.).
    - Send a `POST` request to `/api/tickets` with the data, including the `X-USER-ROLE` header set to `reporter`.
    - Assert the response status is `201 Created`.
    - Assert the response JSON structure contains the created ticket data.
    - Assert that the new ticket exists in the `tickets` table.
    - Assert that the `tickets` table contains the correct `tags` data (using `json_encode`).
    - Assert that the `creator_id` on the created ticket matches the ID of `$this->reporter`.

3.  **Test `GET /api/tickets/{id}` (Show):**
    - Write a test method `test_it_can_show_a_ticket()`.
    - Create a ticket using its factory.
    - Send a `GET` request to `/api/tickets/{ticket_id}`.
    - Assert the response status is `200 OK`.
    - Assert the response JSON contains the correct ticket data (e.g., `data.title`) and the eager-loaded `assignee` relationship.

4.  **Test `PUT /api/tickets/{id}` (Update):**
    - Write a test method `test_it_can_update_a_ticket()`.
    - Create a ticket.
    - Prepare an array with new data (e.g., a new `title` and `status`, and `tags`).
    - Send a `PUT` request to `/api/tickets/{ticket_id}` with the new data, including the `X-USER-ROLE` header set to `admin` (or any valid role).
    - Assert the response status is `200 OK`.
    - Assert the response JSON contains the updated data.
    - Assert the `tickets` table in the database reflects the update.
    - Assert that the `tickets` table contains the correct `tags` data (using `json_encode`) if tags were updated.

5.  **Test `DELETE /api/tickets/{id}` (Destroy):**
    - Write a test method `test_it_can_delete_a_ticket()`.
    - Create a ticket.
    - Send a `DELETE` request to `/api/tickets/{ticket_id}`, including the `X-USER-ROLE` header set to `admin` (or any valid role).
    - Assert the response status is `204 No Content`.
    - Assert the ticket is missing from the `tickets` table (`assertDatabaseMissing`).

Provide the full PHP code for `backend/tests/Feature/TicketCrudTest.php`.

"""

[commands."backend:make-tests-feature-logic"]
prompt = """
As a Laravel developer, your task is to create a feature test file to verify the key business logic of the tickets API, including filtering, authorization, and side effects.

**Context Files:**
{{file "backend/routes/api.php"}}
{{file "backend/app/Http/Controllers/TicketController.php"}}
{{file "backend/app/Models/User.php"}}
{{file "backend/app/Models/Ticket.php"}}
{{file "backend/app/Models/TicketStatusChange.php"}}
{{file "backend/database/factories/UserFactory.php"}}
{{file "backend/database/factories/TicketFactory.php"}}
{{file "backend/app/Enums/UserRole.php"}}
{{file "backend/app/Enums/TicketStatus.php"}}

You need to create a new PHPUnit test file: `backend/tests/Feature/TicketLogicTest.php`.

**Instructions:**

1.  **Test File Setup:**
    - Create a test class `TicketLogicTest` that extends `Tests\TestCase`.
    - Use the `RefreshDatabase` trait.
    - In a `setUp()` method, create one user for each role (`admin`, `agent`, `reporter`) and store them as properties of the test class for easy access.

2.  **Test Filtering Logic (`index` endpoint):**
    - Write a test method `test_it_filters_tickets_by_status()`.
    - Create several tickets: two with `status: 'new'` and one with `status: 'in_progress'`.
    - Send a `GET` request to `/api/tickets?status=new` with the `X-USER-ROLE` header set to `admin`.
    - Assert the response status is `200 OK`.
    - Assert that the response JSON contains exactly 2 items.
    - Assert that the `id` of the 'in_progress' ticket is NOT present in the response.

3.  **Test Authorization Logic (`index` endpoint):**
    - Write a test method `test_reporter_can_only_see_their_own_tickets()`.
    - Create two reporter users, `$reporter1` and `$reporter2`.
    - Create a ticket with `$reporter1` as the creator.
    - Create a ticket with `$reporter2` as the creator.
    - Send a `GET` request to `/api/tickets` with the `X-USER-ROLE` header set to `reporter`. **Important:** The controller logic currently finds the first user with the 'reporter' role. Ensure your test setup reflects this by making `$reporter1` the first one created.
    - Assert the response status is `200 OK`.
    - Assert the response JSON contains the ticket created by `$reporter1`.
    - Assert the response JSON does NOT contain the ticket created by `$reporter2`.

4.  **Test Status Change Logging (`update` endpoint):**
    - Write a test method `test_it_logs_status_change_on_update()`.
    - Create a ticket with `status: 'new'`.
    - Assert that the `ticket_status_changes` table is empty for this ticket's ID.
    - Send a `PUT` request to `/api/tickets/{ticket_id}` with a new `status: 'in_progress'`.
    - Assert the response status is `200 OK`.
    - Assert that the `ticket_status_changes` table now has one record for this ticket.
    - Assert that this new record has `old_status: 'new'` and `new_status: 'in_progress'`.

Provide the full PHP code for `backend/tests/Feature/TicketLogicTest.php`.

"""

[commands."backend:make-tests-feature-services"]
prompt = """
As a Laravel developer, your task is to create a feature test file for the remaining, non-CRUD API endpoints, including mocking external services and testing cache behavior.

**Context Files:**
{{file "backend/routes/api.php"}}
{{file "backend/app/Http/Controllers/TicketController.php"}}
{{file "backend/app/Models/Ticket.php"}}
{{file "backend/database/factories/TicketFactory.php"}}

You need to create a new PHPUnit test file: `backend/tests/Feature/ExtraApiEndpointsTest.php`.

**Instructions:**

1.  **Test File Setup:**
    - Create a test class `ExtraApiEndpointsTest` that extends `Tests\TestCase`.
    - Use the `RefreshDatabase` trait.

2.  **Test `triage-suggest` Endpoint:**
    - Write a test method `test_triage_suggest_returns_correct_mock_response()`.
    - Create a `Ticket` using its factory.
    - Send a `POST` request to the `/api/tickets/{ticket}/triage-suggest` endpoint.
    - Assert the response status is `200 OK`.
    - Assert the response JSON exactly matches the expected mock structure: `{"suggested_status": "in_progress", "suggested_priority": "high", "suggested_tags": ["triage", "auto"]}`.

3.  **Test `external-user-info` Endpoint (Success & Caching):**
    - Write a test method `test_external_user_info_returns_name_and_caches_response()`.
    - Use `Http::fake()` to mock the external API. Define a fake response for `https://jsonplaceholder.typicode.com/users/1` that returns a `200` status and `['name' => 'Leanne Graham']`.
    - **First call:** Send a `GET` request to `/api/external-user-info`.
      - Assert status `200 OK`.
      - Assert the response JSON is `['name' => 'Leanne Graham']`.
      - Assert that the HTTP request was sent to the correct URL (`Http::assertSent(...)`).
    - **Second call:** Send another `GET` request to the same endpoint.
      - Assert status `200 OK`.
    - **Verify Caching:** Assert that the HTTP request was only sent once in total (`Http::assertSentCount(1)`). This proves the cache is working.

4.  **Test `external-user-info` Endpoint (Failure):**
    - Write a test method `test_external_user_info_handles_api_failure()`.
    - Use `Http::fake()` to mock the external API, but this time return a `500` server error for the URL.
    - Send a `GET` request to `/api/external-user-info`.
    - Assert the response status is `502 Bad Gateway`.
    - Assert the response JSON is `['error' => 'external_api_failed']`.

Provide the full PHP code for `backend/tests/Feature/ExtraApiEndpointsTest.php`.

"""

[commands."backend:make-tests-unit"]
prompt = """
As a Laravel developer, your task is to create unit tests for the Eloquent model relationships based on the provided `project_spec.md` and the existing model and enum files.
The database used is PostgreSQL.

{{file "project_spec.md"}}
{{file "backend/app/Enums/UserRole.php"}}
{{file "backend/app/Enums/TicketPriority.php"}}
{{file "backend/app/Enums/TicketStatus.php"}}
{{file "backend/app/Models/User.php"}}
{{file "backend/app/Models/Ticket.php"}}
{{file "backend/app/Models/TicketStatusChange.php"}}
{{file "backend/database/factories/UserFactory.php"}}
{{file "backend/database/factories/TicketFactory.php"}}

You need to create a new PHPUnit test file: `backend/tests/Unit/ModelRelationshipsTest.php`.

**Instructions:**

1.  **Test File Setup:**
    - Create a test class `ModelRelationshipsTest` that extends `Tests\TestCase`.
    - Use the `RefreshDatabase` trait to ensure a clean database state for each test.

2.  **User Model Relationship Tests:**
    - Write a test method `test_user_has_many_created_tickets()`:
      - Create a `User` (reporter role).
      - Create several `Ticket` instances, associating them with this user as the `creator`.
      - Assert that `user->ticketsCreated` returns a collection of `Ticket` instances and contains the correct number of tickets.
    - Write a test method `test_user_has_many_assigned_tickets()`:
      - Create a `User` (agent role).
      - Create several `Ticket` instances, associating them with this user as the `assignee`.
      - Assert that `user->ticketsAssigned` returns a collection of `Ticket` instances and contains the correct number of tickets.

3.  **Ticket Model Relationship Tests:**
    - Write a test method `test_ticket_belongs_to_creator()`:
      - Create a `User` and a `Ticket` with this user as `creator`.
      - Assert that `ticket->creator` returns an instance of `User`.
    - Write a test method `test_ticket_belongs_to_assignee()`:
      - Create a `User` and a `Ticket` with this user as `assignee`.
      - Assert that `ticket->assignee` returns an instance of `User`.
    - Write a test method `test_ticket_has_many_status_changes()`:
      - Create a `Ticket`.
      - Create several `TicketStatusChange` instances, associating them with this ticket.
      - Assert that `ticket->statusChanges` returns a collection of `TicketStatusChange` instances and contains the correct number of changes.

4.  **TicketStatusChange Model Relationship Tests:**
    - Write a test method `test_ticket_status_change_belongs_to_ticket()`:
      - Create a `Ticket` and a `TicketStatusChange` with this ticket.
      - Assert that `statusChange->ticket` returns an instance of `Ticket`.

**General Guidelines:**
- Use model factories to create test data efficiently.
- Ensure all necessary `use` statements are present.

Provide the full PHP code for `backend/tests/Unit/ModelRelationshipsTest.php`.

"""

[commands."backend:refactor-controller"]
prompt = """
As a Laravel developer, your task is to refactor the existing `TicketController.php` to eliminate hard-coded user IDs and replace them with a dynamic, database-driven approach.

**Context Files:**
{{file "backend/app/Http/Controllers/TicketController.php"}}
{{file "backend/app/Models/User.php"}}
{{file "backend/app/Enums/UserRole.php"}}

**Problem:**
The current `TicketController.php` uses a hard-coded constant `REPORTER_USER_ID` and a `resolveCreatorId` method with hard-coded IDs (1, 2, 3). This is brittle and will break if the database seed order changes.

**Refactoring Instructions:**

1.  **Remove Hard-Coded Logic:**
    - Delete the `private const REPORTER_USER_ID = 3;` constant.
    - Delete the `private function resolveCreatorId(...)` method.

2.  **Create a Dynamic Helper Method:**
    - Create a new private helper method, for example, `getUserIdByRole(UserRole $role): ?int`.
    - This method should accept a `UserRole` enum case.
    - It should query the `users` table to find the ID of the first user with that role (e.g., `User::where('role', $role)->value('id')`).
    - **Important:** Cache the result of this query for 1 minute to improve performance and avoid hitting the database on every request for the same role. The cache key should be dynamic based on the role (e.g., `user_id_for_role_{$role->value}`).

3.  **Update the `index` Method:**
    - In the authorization logic for reporters, replace the hard-coded ID with a call to your new helper method: `$query->where('creator_id', $this->getUserIdByRole(UserRole::Reporter));`.

4.  **Update the `store` Method:**
    - In the logic for setting `creator_id`, replace the call to `resolveCreatorId`.
    - The `creator_id` should be determined by finding the user ID for the 'reporter' role. For this MVP, we can assume the creator is always the main reporter. Use your new helper method: `$this->getUserIdByRole(UserRole::Reporter)`.

Provide the full, refactored PHP code for `backend/app/Http/Controllers/TicketController.php` file.

"""

[commands."backend:refactor-tests-unit"]
prompt = """
As a Laravel developer, your task is to refactor existing unit tests to use model factories correctly and to improve assertion quality.

**Context Files:**
{{file "backend/tests/Unit/ModelRelationshipsTest.php"}}
{{file "backend/app/Models/TicketStatusChange.php"}}
{{file "backend/app/Models/Ticket.php"}}
{{file "backend/app/Models/User.php"}}
{{file "backend/app/Enums/TicketStatus.php"}}

**Tasks:**

**1. Create `TicketStatusChangeFactory.php`:**
   - Create a new model factory at `backend/database/factories/TicketStatusChangeFactory.php`.
   - The factory should be for the `TicketStatusChange` model.
   - The `definition()` method should return sensible defaults:
     - `ticket_id`: Should be associated with a `Ticket` factory.
     - `old_status`: A random value from the `TicketStatus` enum.
     - `new_status`: A random value from the `TicketStatus` enum.
     - `changed_at`: Should use `now()`.

**2. Refactor `ModelRelationshipsTest.php`:**
   - Modify the existing `backend/tests/Unit/ModelRelationshipsTest.php` file.
   - **Use the new factory:** In the `test_ticket_has_many_status_changes` method, replace the `TicketStatusChange::create()` call with the new `TicketStatusChangeFactory`.
   - **Improve `hasMany` assertions:**
     - In `test_user_has_many_created_tickets`, after asserting the count, add an assertion to verify the inverse relationship. Iterate through the collection and check that each ticket's `creator` is the original user. Example: `$user->ticketsCreated->each(fn (Ticket $ticket) => $this->assertTrue($ticket->creator->is($user)));`
     - In `test_user_has_many_assigned_tickets`, do the same for the `assignee` relationship. Example: `$user->ticketsAssigned->each(fn (Ticket $ticket) => $this->assertTrue($ticket->assignee->is($user)));`

Provide the full PHP code for the two new/modified files:
1. `backend/database/factories/TicketStatusChangeFactory.php`
2. `backend/tests/Unit/ModelRelationshipsTest.php`

"""

[commands."frontend:make-services"]
prompt = """
As an Angular developer, your task is to create data services and TypeScript interfaces/models for the frontend application, mirroring the backend data structures and API endpoints.

**Context Files (for backend data structure reference):**
{{file "project_spec.md"}}
{{file "backend/app/Enums/UserRole.php"}}
{{file "backend/app/Enums/TicketPriority.php"}}
{{file "backend/app/Enums/TicketStatus.php"}}
{{file "backend/app/Models/User.php"}}
{{file "backend/app/Models/Ticket.php"}}
{{file "backend/app/Models/TicketStatusChange.php"}}

**Instructions:**

**1. Create Interfaces/Models in `frontend/src/app/models/`:**
   - **`frontend/src/app/models/user.model.ts`:**
     - Define a TypeScript interface `User` with properties: `id: number`, `name: string`, `email: string`, `role: UserRole`.
   - **`frontend/src/app/models/ticket.model.ts`:**
     - Define a TypeScript interface `Ticket` with properties: `id: number`, `title: string`, `description: string`, `priority: TicketPriority`, `status: TicketStatus`, `assignee_id: number | null`, `creator_id: number`, `tags: string[]`, `created_at: string`, `updated_at: string`.
   - **`frontend/src/app/models/ticket-status-change.model.ts`:**
     - Define a TypeScript interface `TicketStatusChange` with properties: `id: number`, `ticket_id: number`, `old_status: TicketStatus`, `new_status: TicketStatus`, `changed_at: string`.
   - **`frontend/src/app/models/enums.ts`:**
     - Define TypeScript enums `UserRole`, `TicketPriority`, `TicketStatus` that mirror the values from the corresponding PHP enums in the backend.

**2. Create `AuthService` in `frontend/src/app/services/auth.service.ts`:**
   - Create an injectable Angular service (`@Injectable()`).
   - It should manage the currently "logged in" user's role. Use a `BehaviorSubject<UserRole | null>` named `currentUserRole$` to hold the current role, initialized to `null`.
   - **Implement `localStorage` persistence:**
     - On service initialization, attempt to load the role from `localStorage`.
     - In `login(role: UserRole)`, store the role in `localStorage`.
     - In `logout()`, remove the role from `localStorage`.
   - Provide methods:
     - `login(role: UserRole): void`: Sets the `currentUserRole$` to the provided role and stores it in `localStorage`.
     - `logout(): void`: Sets `currentUserRole$` to `null` and removes the role from `localStorage`.
     - `getCurrentUserRole(): Observable<UserRole | null>`: Returns `currentUserRole$`.
     - `getSnapshotUserRole(): UserRole | null`: Returns the current value of `currentUserRole$`.

**3. Create `TicketService` in `frontend/src/app/services/ticket.service.ts`:**
   - Create an injectable Angular service (`@Injectable()`).
   - Inject `HttpClient` and `AuthService`.
   - Define a `private apiUrl = '/api';`.
   - Implement the following methods, making HTTP requests to the backend API and returning `Observable`s:
     - `getTickets(filters?: { status?: TicketStatus, priority?: TicketPriority, assignee_id?: number, tag?: string }): Observable<Ticket[]>` (GET /api/tickets)
       - Construct query parameters from `filters`.
       - Add `X-USER-ROLE` header using `AuthService.getSnapshotUserRole()`.
     - `getTicket(id: number): Observable<Ticket>` (GET /api/tickets/{id})
       - Add `X-USER-ROLE` header.
     - `createTicket(ticket: Partial<Ticket>): Observable<Ticket>` (POST /api/tickets)
       - Add `X-USER-ROLE` header.
     - `updateTicket(id: number, ticket: Partial<Ticket>): Observable<Ticket>` (PUT /api/tickets/{id})
       - Add `X-USER-ROLE` header.
     - `deleteTicket(id: number): Observable<void>` (DELETE /api/tickets/{id})
       - Add `X-USER-ROLE` header.
     - `getTriageSuggestion(id: number): Observable<{ suggested_status: TicketStatus, suggested_priority: TicketPriority, suggested_tags: string[] }>` (POST /api/tickets/{id}/triage-suggest)
       - Add `X-USER-ROLE` header.
     - `getExternalUserInfo(): Observable<{ name: string }>` (GET /api/external/user-info)
       - Add `X-USER-ROLE` header.

Provide the full TypeScript code for all the files mentioned above.

"""
